From 38626b7e7f1e32379541dad7211f08ff29d63d33 Mon Sep 17 00:00:00 2001
From: Bins94 <kaipeng94@gmail.com>
Date: Tue, 12 Mar 2019 00:01:27 -0400
Subject: [PATCH 2/2] Attach weight to prog

---
 pkg/rpctype/rpctype.go |  9 +++++----
 prog/clone.go          |  1 +
 prog/prio.go           |  4 ++++
 prog/prog.go           |  1 +
 syz-fuzzer/fuzzer.go   |  1 +
 syz-fuzzer/proc.go     | 27 +++++++++++++++++++++++----
 syz-manager/html.go    |  1 +
 7 files changed, 36 insertions(+), 8 deletions(-)

diff --git a/pkg/rpctype/rpctype.go b/pkg/rpctype/rpctype.go
index 66b61601..569ad712 100644
--- a/pkg/rpctype/rpctype.go
+++ b/pkg/rpctype/rpctype.go
@@ -12,10 +12,11 @@ import (
 )
 
 type RPCInput struct {
-	Call   string
-	Prog   []byte
-	Signal signal.Serial
-	Cover  []uint32
+	Call      string
+	Prog      []byte
+	Signal    signal.Serial
+	Cover     []uint32
+	SigWeight float32
 }
 
 type RPCCandidate struct {
diff --git a/prog/clone.go b/prog/clone.go
index 5ad82c35..1711da2e 100644
--- a/prog/clone.go
+++ b/prog/clone.go
@@ -7,6 +7,7 @@ func (p *Prog) Clone() *Prog {
 	p1 := &Prog{
 		Target: p.Target,
 		Calls:  make([]*Call, len(p.Calls)),
+		Weight: p.Weight,
 	}
 	newargs := make(map[*ResultArg]*ResultArg)
 	for ci, c := range p.Calls {
diff --git a/prog/prio.go b/prog/prio.go
index eaec3a70..27e8ed5c 100644
--- a/prog/prio.go
+++ b/prog/prio.go
@@ -7,6 +7,7 @@ import (
 	"fmt"
 	"math/rand"
 	"sort"
+	"github.com/google/syzkaller/pkg/log"
 )
 
 // Calulation of call-to-call priorities.
@@ -142,11 +143,14 @@ func (target *Target) calcDynamicPrio(corpus []*Prog) [][]float32 {
 		prios[i] = make([]float32, len(target.Syscalls))
 	}
 	for _, p := range corpus {
+		log.Logf(0, "Prog with weight: %v", p.Weight)
 		for _, c0 := range p.Calls {
 			for _, c1 := range p.Calls {
 				id0 := c0.Meta.ID
 				id1 := c1.Meta.ID
 				prios[id0][id1] += 1.0
+				/* Only for choosing syscalls */
+				//prios[id0][id1] += (p.Weight*1.0)
 			}
 		}
 	}
diff --git a/prog/prog.go b/prog/prog.go
index 83e5991d..fb9ba353 100644
--- a/prog/prog.go
+++ b/prog/prog.go
@@ -11,6 +11,7 @@ type Prog struct {
 	Target   *Target
 	Calls    []*Call
 	Comments []string
+	Weight   float32
 }
 
 type Call struct {
diff --git a/syz-fuzzer/fuzzer.go b/syz-fuzzer/fuzzer.go
index 52fa30de..50b5b067 100644
--- a/syz-fuzzer/fuzzer.go
+++ b/syz-fuzzer/fuzzer.go
@@ -339,6 +339,7 @@ func (fuzzer *Fuzzer) addInputFromAnotherFuzzer(inp rpctype.RPCInput) {
 	}
 	sig := hash.Hash(inp.Prog)
 	sign := inp.Signal.Deserialize()
+	p.Weight = 1.0
 	fuzzer.addInputToCorpus(p, sign, sig)
 }
 
diff --git a/syz-fuzzer/proc.go b/syz-fuzzer/proc.go
index ca12a97c..d37d2bd8 100644
--- a/syz-fuzzer/proc.go
+++ b/syz-fuzzer/proc.go
@@ -95,6 +95,17 @@ func (proc *Proc) loop() {
 			proc.execute(proc.execOpts, p, ProgNormal, StatGenerate)
 		} else {
 			// Mutate an existing prog.
+			/* Don't use 'Probability Cumulative Distribution'
+                         * eliminate the effects of other new prog
+                         */
+			/*for {
+				p = corpus[proc.rnd.Intn(len(corpus))].Clone()
+				r := float32(proc.rnd.Intn(MAX_WEIGHT))
+				log.Logf(0, "Try a new prog from corpus, r:%v, weight:%v", r, p.Weight)
+				if(r < p.Weight) {
+					break
+				}
+			}*/
 			p := corpus[proc.rnd.Intn(len(corpus))].Clone()
 			p.Mutate(proc.rnd, programLength, ct, corpus)
 			log.Logf(1, "#%v: mutated", proc.pid)
@@ -126,6 +137,7 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 	)
 	// Compute input coverage and non-flaky signal for minimization.
 	notexecuted := 0
+	var tmpWeight float32 = 1.0
 	for i := 0; i < signalRuns; i++ {
 		info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)
 		if !reexecutionSuccess(info, &item.info, item.call) {
@@ -134,6 +146,9 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 			if notexecuted > signalRuns/2+1 {
 				return // if happens too often, give up
 			}
+			/* State signal with useful information */
+			//tmpWeight = getWeightFromState(info)
+			//tmpWeight += getWeightFromCover(info)
 			continue
 		}
 		thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)
@@ -154,6 +169,8 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 						// The call was not executed or failed.
 						continue
 					}
+					//tmpWeight = getWeightFromState(info)
+					//tmpWeight += getWeightFromCover(info)
 					thisSignal, _ := getSignalAndCover(p1, info, call1)
 					if newSignal.Intersection(thisSignal).Len() == newSignal.Len() {
 						return true
@@ -165,13 +182,15 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 
 	data := item.p.Serialize()
 	sig := hash.Hash(data)
+	item.p.Weight = tmpWeight
 
 	log.Logf(2, "added new input for %v to corpus:\n%s", logCallName, data)
 	proc.fuzzer.sendInputToManager(rpctype.RPCInput{
-		Call:   callName,
-		Prog:   data,
-		Signal: inputSignal.Serialize(),
-		Cover:  inputCover.Serialize(),
+		Call:      callName,
+		Prog:      data,
+		Signal:    inputSignal.Serialize(),
+		Cover:     inputCover.Serialize(),
+		SigWeight: item.p.Weight,
 	})
 
 	proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)
diff --git a/syz-manager/html.go b/syz-manager/html.go
index b90a5aa6..3f38f311 100644
--- a/syz-manager/html.go
+++ b/syz-manager/html.go
@@ -327,6 +327,7 @@ func (mgr *Manager) httpPrio(w http.ResponseWriter, r *http.Request) {
 	var corpus []*prog.Prog
 	for _, inp := range mgr.corpus {
 		p, err := mgr.target.Deserialize(inp.Prog, prog.NonStrict)
+		p.Weight = inp.SigWeight
 		if err != nil {
 			http.Error(w, fmt.Sprintf("failed to deserialize program: %v", err), http.StatusInternalServerError)
 			return
-- 
2.20.1

