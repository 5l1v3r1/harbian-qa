diff --git a/pkg/rpctype/rpctype.go b/pkg/rpctype/rpctype.go
index 66b61601..569ad712 100644
--- a/pkg/rpctype/rpctype.go
+++ b/pkg/rpctype/rpctype.go
@@ -12,10 +12,11 @@ import (
 )
 
 type RPCInput struct {
-	Call   string
-	Prog   []byte
-	Signal signal.Serial
-	Cover  []uint32
+	Call      string
+	Prog      []byte
+	Signal    signal.Serial
+	Cover     []uint32
+	SigWeight float32
 }
 
 type RPCCandidate struct {
diff --git a/prog/clone.go b/prog/clone.go
index 5ad82c35..1711da2e 100644
--- a/prog/clone.go
+++ b/prog/clone.go
@@ -7,6 +7,7 @@ func (p *Prog) Clone() *Prog {
 	p1 := &Prog{
 		Target: p.Target,
 		Calls:  make([]*Call, len(p.Calls)),
+		Weight: p.Weight,
 	}
 	newargs := make(map[*ResultArg]*ResultArg)
 	for ci, c := range p.Calls {
diff --git a/prog/prio.go b/prog/prio.go
index eaec3a70..70d81fe9 100644
--- a/prog/prio.go
+++ b/prog/prio.go
@@ -7,6 +7,7 @@ import (
 	"fmt"
 	"math/rand"
 	"sort"
+	"github.com/google/syzkaller/pkg/log"
 )
 
 // Calulation of call-to-call priorities.
@@ -142,11 +143,13 @@ func (target *Target) calcDynamicPrio(corpus []*Prog) [][]float32 {
 		prios[i] = make([]float32, len(target.Syscalls))
 	}
 	for _, p := range corpus {
+		log.Logf(0, "A new prog with weight: %v", p.Weight)
 		for _, c0 := range p.Calls {
 			for _, c1 := range p.Calls {
 				id0 := c0.Meta.ID
 				id1 := c1.Meta.ID
 				prios[id0][id1] += 1.0
+				//prios[id0][id1] += (p.Weight*1.0)
 			}
 		}
 	}
diff --git a/prog/prog.go b/prog/prog.go
index 83e5991d..fb9ba353 100644
--- a/prog/prog.go
+++ b/prog/prog.go
@@ -11,6 +11,7 @@ type Prog struct {
 	Target   *Target
 	Calls    []*Call
 	Comments []string
+	Weight   float32
 }
 
 type Call struct {
diff --git a/syz-fuzzer/fuzzer.go b/syz-fuzzer/fuzzer.go
index d41dfe66..facf1f08 100644
--- a/syz-fuzzer/fuzzer.go
+++ b/syz-fuzzer/fuzzer.go
@@ -336,6 +336,7 @@ func (fuzzer *Fuzzer) addInputFromAnotherFuzzer(inp rpctype.RPCInput) {
 	}
 	sig := hash.Hash(inp.Prog)
 	sign := inp.Signal.Deserialize()
+	p.Weight = 1.0
 	fuzzer.addInputToCorpus(p, sign, sig)
 }
 
diff --git a/syz-fuzzer/proc.go b/syz-fuzzer/proc.go
index ca12a97c..75db2277 100644
--- a/syz-fuzzer/proc.go
+++ b/syz-fuzzer/proc.go
@@ -126,6 +126,7 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 	)
 	// Compute input coverage and non-flaky signal for minimization.
 	notexecuted := 0
+	var tmpWeight float32 = 1.0
 	for i := 0; i < signalRuns; i++ {
 		info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)
 		if !reexecutionSuccess(info, &item.info, item.call) {
@@ -134,6 +135,8 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 			if notexecuted > signalRuns/2+1 {
 				return // if happens too often, give up
 			}
+			//tmpWeight = getWeightFromState(info)
+			//tmpWeight += getWeightFromCover(info)
 			continue
 		}
 		thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)
@@ -154,6 +157,9 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 						// The call was not executed or failed.
 						continue
 					}
+					//tmpWeight = getWeightFromState(info)
+					//tmpWeight += getWeightFromCover(info)
+
 					thisSignal, _ := getSignalAndCover(p1, info, call1)
 					if newSignal.Intersection(thisSignal).Len() == newSignal.Len() {
 						return true
@@ -165,13 +171,15 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 
 	data := item.p.Serialize()
 	sig := hash.Hash(data)
+	item.p.Weight = tmpWeight
 
 	log.Logf(2, "added new input for %v to corpus:\n%s", logCallName, data)
 	proc.fuzzer.sendInputToManager(rpctype.RPCInput{
-		Call:   callName,
-		Prog:   data,
-		Signal: inputSignal.Serialize(),
-		Cover:  inputCover.Serialize(),
+		Call:      callName,
+		Prog:      data,
+		Signal:    inputSignal.Serialize(),
+		Cover:     inputCover.Serialize(),
+		SigWeight: item.p.Weight,
 	})
 
 	proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)
diff --git a/syz-manager/html.go b/syz-manager/html.go
index b90a5aa6..3f38f311 100644
--- a/syz-manager/html.go
+++ b/syz-manager/html.go
@@ -327,6 +327,7 @@ func (mgr *Manager) httpPrio(w http.ResponseWriter, r *http.Request) {
 	var corpus []*prog.Prog
 	for _, inp := range mgr.corpus {
 		p, err := mgr.target.Deserialize(inp.Prog, prog.NonStrict)
+		p.Weight = inp.SigWeight
 		if err != nil {
 			http.Error(w, fmt.Sprintf("failed to deserialize program: %v", err), http.StatusInternalServerError)
 			return
