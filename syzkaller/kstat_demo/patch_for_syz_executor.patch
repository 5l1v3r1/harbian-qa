diff --git a/executor/common.h b/executor/common.h
index 49a2cbd6..aba073aa 100644
--- a/executor/common.h
+++ b/executor/common.h
@@ -423,7 +423,7 @@ static void* thr(void* arg)
 }
 
 #if SYZ_REPEAT
-static void execute_one(void)
+static void execute_one(int shmid, int pidshid, int monpid)
 #else
 static void loop(void)
 #endif
@@ -476,7 +476,7 @@ again:
 #endif
 
 #if SYZ_EXECUTOR || SYZ_REPEAT
-static void execute_one(void);
+static void execute_one(int shmid, int pidshid, int monpid);
 #if SYZ_EXECUTOR_USES_FORK_SERVER
 #include <signal.h>
 #include <sys/types.h>
@@ -492,7 +492,7 @@ static void execute_one(void);
 static void reply_handshake();
 #endif
 
-static void loop(void)
+static void loop(int shmid, int pidshid, int monpid)
 {
 #if SYZ_HAVE_SETUP_LOOP
 	setup_loop();
@@ -553,7 +553,7 @@ static void loop(void)
 #if SYZ_EXECUTOR && SYZ_EXECUTOR_USES_SHMEM
 			close(kOutPipeFd);
 #endif
-			execute_one();
+			execute_one(shmid, pidshid, monpid);
 #if SYZ_HAVE_RESET_TEST
 			reset_test();
 #endif
diff --git a/executor/common_linux.h b/executor/common_linux.h
index 00c78c6a..c0337f0a 100644
--- a/executor/common_linux.h
+++ b/executor/common_linux.h
@@ -1487,7 +1487,7 @@ static void setup_common()
 #include <sys/time.h>
 #include <sys/wait.h>
 
-static void loop();
+static void loop(int shmid, int pidshid, int monpid);
 
 static void sandbox_common()
 {
@@ -1504,7 +1504,8 @@ static void sandbox_common()
 	close(netns);
 #endif
 
-	struct rlimit rlim;
+	/* RLIMIT_STACK will break ebpf load, unknow reason */
+	/*	struct rlimit rlim;
 	rlim.rlim_cur = rlim.rlim_max = 200 << 20;
 	setrlimit(RLIMIT_AS, &rlim);
 	rlim.rlim_cur = rlim.rlim_max = 32 << 20;
@@ -1516,7 +1517,7 @@ static void sandbox_common()
 	rlim.rlim_cur = rlim.rlim_max = 0;
 	setrlimit(RLIMIT_CORE, &rlim);
 	rlim.rlim_cur = rlim.rlim_max = 256; // see kMaxFd
-	setrlimit(RLIMIT_NOFILE, &rlim);
+	setrlimit(RLIMIT_NOFILE, &rlim);*/
 
 	// CLONE_NEWNS/NEWCGROUP cause EINVAL on some systems,
 	// so we do them separately of clone in do_sandbox_namespace.
@@ -1561,9 +1562,10 @@ static int do_sandbox_none(void)
 	// and they are usually run under non-root.
 	// Also since debug is stripped by pkg/csource, we need to do {}
 	// even though we generally don't do {} around single statements.
-	if (unshare(CLONE_NEWPID)) {
+        /* New pid namespace make it difficult to monitor */
+	/*if (unshare(CLONE_NEWPID)) {
 		debug("unshare(CLONE_NEWPID): %d\n", errno);
-	}
+		}*/
 	int pid = fork();
 	if (pid != 0)
 		return wait_for_loop(pid);
@@ -1579,7 +1581,41 @@ static int do_sandbox_none(void)
 #if SYZ_EXECUTOR || SYZ_ENABLE_NETDEV
 	initialize_netdevices();
 #endif
-	loop();
+	/* Read shared memory id */
+	int monpipefd[2];
+	int ret = pipe(monpipefd);
+	if (ret < 0)
+	  fail("Pipe create failed\n");
+
+	int monpid = fork();
+	if (monpid == 0) {
+	  prctl(PR_SET_PDEATHSIG, SIGINT);
+	  dup2(monpipefd[1], STDOUT_FILENO);
+	  /* For reading monitor log print */
+	  /*close(monpipefd[0]);
+	    close(monpipefd[1]);*/
+	  debug("shm_monitor start ...\n");
+	  execl("/root/shm_monitor", "/root/shm_monitor", NULL);
+	  return 0;
+	}
+	/* ebpf loading is very slow */
+	sleep(6);
+
+	close(monpipefd[1]);
+	char id[9];
+	int shmid, pidshid;
+	read(monpipefd[0], id, sizeof(char)*8);
+	id[8] = '\0';
+	shmid = strtol(id, NULL, 10);
+	debug("Read shared memory id %d\n", shmid);
+	read(monpipefd[0], id, sizeof(char)*8);
+	id[8] = '\0';
+	pidshid = strtol(id, NULL, 10);
+	debug("Read shared memory id %d\n", pidshid);
+	close(monpipefd[0]);
+
+	/* Only sandbox_none, feed zero to others */
+	loop(shmid, pidshid, monpid);
 	doexit(1);
 }
 #endif
@@ -1624,7 +1660,7 @@ static int do_sandbox_setuid(void)
 	// See task_dump_owner function in kernel.
 	prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
 
-	loop();
+	loop(0,0,0);
 	doexit(1);
 }
 #endif
@@ -1747,7 +1783,7 @@ static int namespace_sandbox_proc(void* arg)
 	if (syscall(SYS_capset, &cap_hdr, &cap_data))
 		fail("capset failed");
 
-	loop();
+	loop(0,0,0);
 	doexit(1);
 }
 
@@ -1902,7 +1938,7 @@ static int do_sandbox_android_untrusted_app(void)
 	initialize_netdevices();
 #endif
 
-	loop();
+	loop(0,0,0);
 	doexit(1);
 }
 #endif
diff --git a/executor/executor.cc b/executor/executor.cc
index 68c98155..953d7be6 100644
--- a/executor/executor.cc
+++ b/executor/executor.cc
@@ -15,6 +15,9 @@
 #include <time.h>
 #include <unistd.h>
 
+/* For shared memory */
+#include <sys/shm.h>
+
 #include "defs.h"
 
 #if defined(__GNUC__)
@@ -541,8 +544,23 @@ void reply_execute(int status)
 }
 
 // execute_one executes program stored in input_data.
-void execute_one()
+void execute_one(int shmid, int pidshid, int monpid)
 {
+  /* Get shared memory address */
+  uint32_t *sigmem;
+  sigmem = (uint32_t*)shmat(shmid, NULL, SHM_RDONLY);
+  if (!sigmem)
+    fail("Failed to get shared memory\n");
+  /* Write the pid to monitor */
+  uint64_t *pidmem;
+  pidmem = (uint64_t*)shmat(pidshid, NULL, 0);
+  if (!pidmem)
+    fail("Failed to get shared memory\n");
+  debug("Shared memory fetch! Sigmem is %p, Pidshmem is %p\n", sigmem, pidmem);
+  *pidmem = (uint64_t)getpid();
+  /* Need time to read the pid */
+  sleep_ms(10);
+
 	// Duplicate global collide variable on stack.
 	// Fuzzer once come up with ioctl(fd, FIONREAD, 0x920000),
 	// where 0x920000 was exactly collide address, so every iteration reset collide to 0.
@@ -690,6 +708,29 @@ retry:
 			handle_completion(th);
 		}
 	}
+	/* Send SIGUSR1 to close ebpf tracepipe */
+	debug("Before send SIGUSR1 signal\n");
+	kill(monpid, SIGUSR1);
+	/* Need time for handling the raw data */
+	sleep_ms(1500);
+	debug("Read beigin\n");
+	uint32 nsig = 0;
+	/* At first I try to make it look like a coverage signal */
+	/* rawsignal should be less than 401 */
+	for(uint32 i=0; i<401; i++) {
+	  uint32_t rawsignal = 0;
+	  rawsignal = *(sigmem + i);
+	  if (dedup(rawsignal))
+	    continue;
+	  if (rawsignal == 0)
+	    continue;
+	  if (rawsignal == 0xffffffff)
+	    break;
+	  nsig++;
+	  debug("Got a special signal %x\n", rawsignal);
+	}
+	debug("Got %d special signal\n", nsig);
+	kill(monpid, SIGKILL);
 
 	if (!colliding && !collide && running > 0) {
 		// Give unfinished syscalls some additional time.
@@ -719,9 +760,9 @@ retry:
 			}
 		}
 	}
-
+	
 	if (flag_collide && !flag_inject_fault && !colliding && !collide) {
-		debug("enabling collider\n");
+	        debug("enabling collider\n");
 		collide = colliding = true;
 		goto retry;
 	}
